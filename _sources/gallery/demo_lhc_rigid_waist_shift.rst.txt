
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/demo_lhc_rigid_waist_shift.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_gallery_demo_lhc_rigid_waist_shift.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_demo_lhc_rigid_waist_shift.py:


.. _demo-rigid-waist-shift:

=====================
LHC Rigid Waist Shift
=====================

This example shows how to use the `~.lhc.apply_lhc_rigidity_waist_shift_knob` 
function to force a waist shift at a given IP and break the symmetry of the 
:math:`\beta`-functions in the Interaction Region.

We will do a comparison of the interaction region situation before and after 
applying a rigid waist shift.

.. note::
    This is very specific to the LHC machine and the implementation would not 
    work on other accelerators.

.. GENERATED FROM PYTHON SOURCE LINES 20-33

.. code-block:: default

    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd

    from cpymad.madx import Madx

    from pyhdtoolkit.cpymadtools import lhc, matching
    from pyhdtoolkit.cpymadtools.plotters import LatticePlotter
    from pyhdtoolkit.utils import _misc, defaults

    defaults.config_logger(level="warning")
    plt.rcParams.update(defaults._SPHINX_GALLERY_PARAMS)  # for readability of this tutorial








.. GENERATED FROM PYTHON SOURCE LINES 35-36

Let's start by setting up the LHC in ``MAD-X``, in this case at top energy:

.. GENERATED FROM PYTHON SOURCE LINES 36-41

.. code-block:: default


    madx = Madx(stdout=False)
    madx.call("lhc/lhc_as-built.seq")
    madx.call("lhc/opticsfile.22")  # collision optics








.. GENERATED FROM PYTHON SOURCE LINES 42-44

Let's re-cycle the sequences to avoid having IR1 split at beginning and end of lattice,
as is the default in the LHC sequence:

.. GENERATED FROM PYTHON SOURCE LINES 44-49

.. code-block:: default


    lhc.re_cycle_sequence(madx, sequence="lhcb1", start="IP3")
    lhc.make_lhc_beams(madx, energy=7000)
    madx.command.use(sequence="lhcb1")








.. GENERATED FROM PYTHON SOURCE LINES 50-53

We will use the `~.plotters.LatticePlotter.plot_latwiss` function to have zoomed-in
look at the Interaction Region 1 by providing the *xlimits* parameter. Let's first
determine the position of points of interest through the ``TWISS`` table:

.. GENERATED FROM PYTHON SOURCE LINES 53-59

.. code-block:: default


    madx.command.twiss()
    twiss_df = madx.table.twiss.dframe().copy()
    twiss_df.name = twiss_df.name.apply(lambda x: x[:-2])
    ip1s = twiss_df.s["ip1"]








.. GENERATED FROM PYTHON SOURCE LINES 60-61

Let's now have a look at the IR in normal conditions.

.. GENERATED FROM PYTHON SOURCE LINES 61-78

.. code-block:: default


    IR1_fig = LatticePlotter.plot_latwiss(
        madx,
        figsize=(18, 11),
        title="LHCB1 IR1 - No Rigid Waist Shift",
        disp_ylim=(-1.5, 3),
        xoffset=ip1s,
        xlimits=(-200, 200),
        k0l_lim=(-2e-3, 2e-3),
        k1l_lim=(-6.1e-2, 6.1e-2),
        lw=1.5,
    )
    IR1_fig.axes[-2].set_xlabel(r"$\mathrm{Distance\ to\ IP1\ [m]}$")
    for axis in IR1_fig.axes:
        axis.axvline(x=0, color="grey", ls="--", lw=1.5, label="IP1")
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_001.svg
   :alt: LHCB1 IR1 - No Rigid Waist Shift
   :srcset: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_001.svg, /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_001_2_0x.svg 2.0x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 79-93

Notice the (anti)symmetry of the :math:`\beta_{x,y}` functions and triplet
quadrupoles powering on the right and left-hand side of the IP. Let's now apply
a rigid waist shift - meaning all four betatron waists moving simultaneously - by
changing the triplets powering. This is handled by the convenient function
`~.lhc.apply_lhc_rigidity_waist_shift_knob`.

It is possible to choose the knob's strength, in which IR to apply it, and on
which side of the IP to shift the beam waist. See the function documentation
for more details. After applying the knob, we will re-match to our working point
to make sure we do not deviate.

.. hint::
   A waist shift knob setting of 1 will result in a 0.5% change in the triplets
   knob powering. The individual triplet magnets trims are not affected.

.. GENERATED FROM PYTHON SOURCE LINES 93-97

.. code-block:: default


    lhc.apply_lhc_rigidity_waist_shift_knob(madx, rigidty_waist_shift_value=1.5, ir=1)
    matching.match_tunes_and_chromaticities(madx, "lhc", "lhcb1", 62.31, 60.32, 2.0, 2.0)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    2022-05-04 19:29:54 | WARNING  | pyhdtoolkit.cpymadtools.lhc:241 - You should re-match tunes & chromaticities after this rigid waist shift knob is applied




.. GENERATED FROM PYTHON SOURCE LINES 98-100

Let's again retrieve the ``TWISS`` table, then plot the new conditions in the
Interaction Region.

.. GENERATED FROM PYTHON SOURCE LINES 100-121

.. code-block:: default


    twiss_df_waist = madx.table.twiss.dframe().copy()
    twiss_df_waist.name = twiss_df.name.apply(lambda x: x[:-2])
    ip1s = twiss_df_waist.s["ip1"]

    IR1_waist_shift = LatticePlotter.plot_latwiss(
        madx,
        figsize=(16, 11),
        title="LHCB1 IR1 - With Rigid Waist Shift",
        disp_ylim=(-1.5, 3),
        xoffset=ip1s,
        xlimits=(-200, 200),
        k0l_lim=(-2e-3, 2e-3),
        k1l_lim=(-6.1e-2, 6.1e-2),
        lw=1.5,
    )
    IR1_waist_shift.axes[-2].set_xlabel(r"$\mathrm{Distance\ to\ IP1\ [m]}$")
    for axis in IR1_fig.axes:
        axis.axvline(x=0, color="grey", ls="--", lw=1.5, label="IP1")
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_002.svg
   :alt: LHCB1 IR1 - With Rigid Waist Shift
   :srcset: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_002.svg, /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_002_2_0x.svg 2.0x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 122-128

Comparing to the previous plot, one can notice two things:
 - The triplet quadrupoles powering has changed and is not symmetric anymore.
 - The :math:`\beta_{x,y}` functions symmetry has been broken.

One can compare the :math:`\beta_{x,y}` functions before and after the rigid
waist shift with a simple plot:

.. GENERATED FROM PYTHON SOURCE LINES 128-143

.. code-block:: default


    plt.figure(figsize=(16, 10))
    plt.plot(twiss_df.s - ip1s, twiss_df.betx * 1e-3, "b-", label=r"$\beta_{x}^{n}$")
    plt.plot(twiss_df_waist.s - ip1s, twiss_df_waist.betx * 1e-3, "b--", label=r"$\beta_{x}^{w}$")

    plt.plot(twiss_df.s - ip1s, twiss_df.bety * 1e-3, "r-", label=r"$\beta_{y}^{n}$")
    plt.plot(twiss_df_waist.s - ip1s, twiss_df_waist.bety * 1e-3, "r--", label=r"$\beta_{y}^{w}$")

    plt.xlabel(r"$\mathrm{Distance\ to\ IP1\ [m]}$")
    plt.ylabel(r"$\beta_{x,y}\ \mathrm{[km]}$")
    plt.xlim(-200, 200)
    plt.ylim(-5e-1, 9)
    plt.legend()
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_003.svg
   :alt: demo lhc rigid waist shift
   :srcset: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_003.svg, /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_003_2_0x.svg 2.0x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 144-151

Here the subscript **n** stands for nominal, and **w** for the waist shift.

.. tip::
  The differences observed will vary depending on the strength of the knob,
  which we choose with the *rigidty_waist_shift_value* parameter.

Let's not forget to close the rpc connection to ``MAD-X``:

.. GENERATED FROM PYTHON SOURCE LINES 151-154

.. code-block:: default


    madx.exit()








.. GENERATED FROM PYTHON SOURCE LINES 155-165

Let's now determine the value of the waist, aka the amount by which we have
shifted the waist compared to the IP point location. To do so, we will use
both an analytical approach and a more brute force one through simulations.

Let's set up a rigid waist shift, with the addition of many *marker* elements
in the close vicinity of the IP in order to get better resolution when looking
at the :math:`\beta_{x,y}` functions.

Let's do so for the LHC 2022 optics, with pre-calculated knobs use in the LHC
2022 commissioning to speed up this file's execution time.

.. GENERATED FROM PYTHON SOURCE LINES 165-193

.. code-block:: default


    b1_knobs = ["knobs/quadrupoles.madx", "knobs/triplets.madx", "knobs/working_point.madx"]

    with Madx(stdout=False) as madx:
        madx.option(echo=False, warn=False)
        madx.call("acc-models-lhc/lhc.seq")
        lhc.make_lhc_beams(madx, energy=6800)
        madx.call("acc-models-lhc/operation/optics/R2022a_A30cmC30cmA10mL200cm.madx")
        madx.command.use(sequence=f"lhcb1")

        lhc.re_cycle_sequence(madx, sequence=f"lhcb1", start=f"MSIA.EXIT.B1")
        madx.command.use(sequence=f"lhcb1")
        lhc.make_lhc_thin(madx, sequence=f"lhcb1", slicefactor=4)
        _misc.add_markers_around_lhc_ip(madx, sequence=f"lhcb1", ip=1, n_markers=1000, interval=0.001)
        madx.command.twiss()
        initial_twiss = madx.table.twiss.dframe().copy()

        # Calling pre-calculated and re-matched waist shift knobs
        for knobfile in b1_knobs:
            madx.call(knobfile)

        matching.match_tunes(madx, "lhc", f"lhcb1", 62.31, 60.32)
        matching.match_chromaticities(madx, "lhc", f"lhcb1", 2.0, 2.0)
        matching.match_tunes_and_chromaticities(madx, "lhc", f"lhcb1", 62.31, 60.32, 2.0, 2.0)

        madx.command.twiss()
        twiss_df = madx.table.twiss.dframe().copy()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    2022-05-04 19:30:53 | WARNING  | pyhdtoolkit.utils._misc:180 - Sequence 'lhcb1' will be USEd for new markers to be taken in consideration, beware that this will erase errors etc.




.. GENERATED FROM PYTHON SOURCE LINES 194-197

We will use all our added markers to determine the location of the waist,
by simply finding with good resolution the minima of the :math:`\beta_{x,y}`
functions.

.. GENERATED FROM PYTHON SOURCE LINES 197-207

.. code-block:: default


    initial_twiss.name = initial_twiss.name.apply(lambda x: x[:-2])
    twiss_df.name = twiss_df.name.apply(lambda x: x[:-2])
    ip_s = twiss_df.s[f"ip1"]
    slimits = (ip_s - 10, ip_s + 10)

    around_ip = twiss_df[twiss_df.s.between(*slimits)]
    initial_twiss = initial_twiss[initial_twiss.s.between(*slimits)]
    waist_location = around_ip.s[around_ip.betx == around_ip.betx.min()][0]








.. GENERATED FROM PYTHON SOURCE LINES 208-211

We can also plot the :math:`\beta_{x,y}` functions before and after the
application of the rigid waist shift. Here one can clearly see the shift of
the waist between the two configurations

.. GENERATED FROM PYTHON SOURCE LINES 211-257

.. code-block:: default


    fig, axis = plt.subplots(figsize=(15, 10))

    axis.plot(
        around_ip.s - ip_s,
        around_ip.betx,
        ls="-",
        color="blue",
        marker=".",
        label=r"$\beta_x^{\mathrm{waist}}$",
    )
    axis.plot(
        around_ip.s - ip_s,
        around_ip.bety,
        ls="-",
        color="orange",
        marker=".",
        label=r"$\beta_y^{\mathrm{waist}}$",
    )

    axis.axvline(0, color="purple", ls="--", lw=1.5, label=r"$\mathrm{IP1}$")
    axis.axvline(waist_location - ip_s, color="green", ls="--", lw=1.5, label=r"$\mathrm{Waist}$")
    axis.axvspan(waist_location - ip_s, 0, color="red", alpha=0.1)

    axis.plot(
        initial_twiss.s - ip_s,
        initial_twiss.betx,
        ls="-.",
        color="blue",
        alpha=0.5,
        label=r"$\beta_x^{\mathrm{nominal}}$",
    )
    axis.plot(
        initial_twiss.s - ip_s,
        initial_twiss.bety,
        ls="-.",
        color="orange",
        alpha=0.5,
        label=r"$\beta_y^{\mathrm{nominal}}$",
    )

    plt.xlabel(r"$\mathrm{Distance \ to \ IP1 \ [m]}$")
    plt.ylabel(r"$\beta_{x,y} \ \mathrm{[m]}$")
    plt.legend(ncol=2)
    plt.show()




.. image-sg:: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_004.svg
   :alt: demo lhc rigid waist shift
   :srcset: /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_004.svg, /gallery/images/sphx_glr_demo_lhc_rigid_waist_shift_004_2_0x.svg 2.0x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 258-260

The value of the waist is then simply the distance between the IP and the
location of the found minima. Here is the value, in meters:

.. GENERATED FROM PYTHON SOURCE LINES 260-264

.. code-block:: default


    shift = abs(ip_s - waist_location)
    print(shift)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.4350000000013097




.. GENERATED FROM PYTHON SOURCE LINES 265-278

Let's now determine this value using the Eq. 10 formula in this paper
:cite:t:`Carlier:AccuracyFeasibilityMeasurement2017` from Felix Carlier:
:math:`\beta_0 = \beta_w + \frac{(L^{*} - w)^2}{\beta_w}`

where :math:`\beta_0` is the :math:`\beta` function at the end of the
quadrupole (Q1, end closest to IP); :math:`\beta_w`` is the :math:`\beta`
function at the waist itself (found as min of :math:`\beta` function in the
region); :math:`L^{*}` is the distance from close end of quadrupole (Q1) to
the IP point itself; and :math:`w` is the waist displacement we are looking
to figure out.

Manipulating the equation to determine the waist yields:
:math:`w = L^{*} - \sqrt{\beta_0 \beta_w - \beta_w^2}`

.. GENERATED FROM PYTHON SOURCE LINES 278-287

.. code-block:: default


    q1_right_s = twiss_df[twiss_df.name.str.contains(f"mqxa.1r1")].s[0]
    q1_left_s = twiss_df[twiss_df.name.str.contains(f"mqxa.1l1")].s[-1]  # to calculate from the left

    L_star = ip_s - q1_left_s
    beta0 = twiss_df[twiss_df.name.str.contains(f"mqxa.1r1")].betx[0]
    # beta0 = twiss_df[twiss_df.name.str.contains(f"mqxa.1l{IP:d}")].betx[-1]  # if calculating from the left
    betaw = around_ip.betx.min()








.. GENERATED FROM PYTHON SOURCE LINES 288-290

The analytical result (sign will swap depending on if we calculate from left
or right Q1) is then:

.. GENERATED FROM PYTHON SOURCE LINES 290-293

.. code-block:: default

    waist = L_star - np.sqrt(beta0 * betaw - betaw**2)
    print(waist)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.43449258337677676




.. GENERATED FROM PYTHON SOURCE LINES 294-295

It is fairly close to the value found with the markers we previously added:

.. GENERATED FROM PYTHON SOURCE LINES 295-297

.. code-block:: default

    print(shift)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    0.4350000000013097




.. GENERATED FROM PYTHON SOURCE LINES 298-306

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `~.cpymadtools.lhc`: `~.lhc.make_lhc_beams`, `~.lhc.re_cycle_sequence`, `~.lhc.apply_lhc_rigidity_waist_shift_knob`
   - `~.cpymadtools.matching`: `~.matching.match_tunes`, `~.matching.match_chromaticities`, `~.matching.match_tunes_and_chromaticities`
   - `~.cpymadtools.plotters`: `~.plotters.LatticePlotter`, `~.plotters.LatticePlotter.plot_latwiss`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 3 minutes  18.013 seconds)


.. _sphx_glr_download_gallery_demo_lhc_rigid_waist_shift.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: demo_lhc_rigid_waist_shift.py <demo_lhc_rigid_waist_shift.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: demo_lhc_rigid_waist_shift.ipynb <demo_lhc_rigid_waist_shift.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
